%!TEX root = ../FYP_Dissertation.tex

%===============================================================================
% Hot path detection
%===============================================================================

\section{Hot path detection}
\label{Sec:hot-path}
LuaJIT does trace compilation. For that, it needs to detect that a certain
portion of the code gets hot and compile it as a trace. Two types of trace entry
are detected, loops and function. In the vm (See Part \ref{Part:VM}) each
traceable loop-like or call-like BC (byte-code) decrement a counter that is the
hashed pc (program counter) position of a (64-entries) table. When the counter underflows it start recording. At the end of the recording phase, it patch the
BC with a call to the compiled trace.

\paratitle{Loops:}

\begin{itemize}
	\item \emph{hotloop} : hash the pc, decrement the corresponding counter and
jmp to vm\_hotloop if it underflows (vm\_(arch).dasc).
	\item \emph{vm\_hotloop} : Prepare the stack and call lj\_trace\_hot.
	\item \emph{lj\_trace\_hot} : start recording a trace (lj\_trace.c).
\end{itemize}

\paratitle{Functions:}

\begin{itemize}
	\item \emph{hotcall} : hash the pc, decrement the corresponding counter and
jmp to vm\_hotcall if it underflows (vm\_(arch).dasc).
	\item \emph{vm\_hotcall} : Prepare the stack and call lj\_dispatch\_call.
	\item \emph{lj\_dispatch\_call} : start recording a trace (lj\_dispatch.c).
\end{itemize}

%===============================================================================
% Recorder state machine
%===============================================================================

\section{Recorder state machine}
\label{Sec:recorder-state-machine}

% Recording:
% ----------
%  - Hashed profile counters: Bytecode instructions to trigger the
%   start of a hot trace use low-overhead hashed profiling counters.
%   The profile is imprecise because collisions are ignored. The
%   hash table is kept very small to reduce D-cache impact (only two
%   hot cache lines). Since NLF weeds out most false positives, this
%   doesn''t deteriorate hot trace detection.

%   [Neither using hashed profile counters, nor imprecise profiling,
%   nor using profiling to detect hot loops is new. But the specific
%   combination may be original.]
% - talk about penalty
% - natural-loop first (NLF) -> region-selection
% - lj_trace.c
%   - trace_state : State machine for the trace compiler.
%     - LJ_TRACE_START : start recording (call to trace_start).
%       change state to LJ_TRACE_RECORD.
%     - LJ_TRACE_RECORD : recording in process (looping over "lj_record_ins").
%     - LJ_TRACE_END : end of recording + apply pending bytcode patch
%       + apply optimizations on IR.
%     - LJ_TRACE_ASM : assemble the trace and call trace_stop().
%     - LJ_TRACE_ERR : abort (trace_abort).
%   - trace_start: does jit_State setup and allocations.
%   - trace_stop: patch the bc to use the compiled version instead of the interpreted
%     once.
%   - trace_abort: does state cleanup, handle Penalize or blacklist.
% - lj_record_ins: is a huge switch case on the bc to record a specific bytcode
%   instruction and generate the corresponding specialized IR code of the instruction
%   before execution. (executed inside a pcall -> _ERR bu throwing lua intarnal exception)
% - lj_record_stop
%   - trace stitching (call to c using c API)
%   - end of the hotloop
%   - hit an other already compiled loop (link to it)
%   - return statement
%     - return to interpretor for unhandled cases
%     - when downrec limit reach for side-trace (nagative frame depth)
%     - tail-rec is detected (limit reach in the same framedepth)
%     - limit reach in up recursion (positive frame depth)
%   - hit a compiled function (link to its trace)
% - there exist two types of trace
%   - parent trace ->
%   - side trace (recursive) ?? ->
% - hot is detected ->
%   - recorde a parent trace
%   - change of the J->state to become LJ_TRACE_START
%   - start recording the first bytecode (run trace_state until abort _ERR or _END)
% - recording is the fact of executing the code while remembering dynamic data/type
%   /controlflow decision to generate a specialized version of this code that
% - Reason to abort -> see abort.txt
% - lj_ffrecord.c: records data for fast function call
% - lj_crecord.c: records C data ops

%===============================================================================
% Abortion and blacklisting
%===============================================================================

\section{Abortion and blacklisting}
\label{Sec:abort}

%===============================================================================
% Intermediate representation
%===============================================================================

\section{Intermediate representation}
\label{Sec:IR}

% IR:
% ----
% - SSA (Static single assignment) based (cf : https://www.wikiwand.com/en/Static_single_assignment_form)
% - Data-flow for loops is represented using PHI-instructions.
% - Control-flow is always implicit.
% - operands are 16 bit references
% - implemented with a bidirectionally growable array
% - Skip-list chains: The IR is threaded with segregated, per-opcode
%   skip-list chains. The links are stored in a multi-purpose 16 bit
%   field in the instruction. This facilitates low-overhead lookup
%   for CSE, DSE and alias analysis. Back-linking enables short-cut
%   searches (average overhead is less than 1 lookup). Incremental
%   build-up is trivial. No hashes, no sets, no complex updates.
% - a single High-level IR across all optimization stage.
% - Trace IR code is represented as an array in memory.
% - The array includes two different things: instructions and constants.
% - Instructions are stored at "upwards" indices 0,1,2,... ( > 0x8000 )
% - Constants are stored at "downwards" indices -1,-2,-3,... ( < 0x8000 )
% - References to array elements are "biased" by adding 0x8000.
% - ir reference are index in the ir array.
% - Every instruction has an output data type.
% - IR constants are interned and can be compared for equality only by looking at their references.
% - Guarded assertions have a dual purpose
%   - They provide an assertion about their operands.
%   - They are emitted by the backend as branching comparisons,
%     - true ->  fall-through path.
%     - false ->  outcome exits the trace and restores the state using last snapshot.

% -- IR instruction format (64 bit).
% --
% --    16      16     8   8   8   8
% -- +-------+-------+---+---+---+---+
% -- |  op1  |  op2  | t | o | r | s |
% -- +-------+-------+---+---+---+---+
% -- |  op12/i/gco32 |   ot  | prev  | (alternative fields in union)
% -- +-------+-------+---+---+---+---+
% -- |  TValue/gco64                 | (2nd IR slot for 64 bit constants)
% -- +---------------+-------+-------+
% --        32           16      16
% --
% -- prev is only valid prior to register allocation and then reused for r + s.
% --
% -- t    : type
% -- o    : opcode
% -- r    : register allocation
% -- s    : spill slot
% -- prev : chain of instruction of same opcode


%===============================================================================
% Snapshots
%===============================================================================

\section{Snapshots}
\label{Sec:snap}

Snapshot is an important mechanism used in trace compilation. The VM should
always be in a consistent state, meaning that all updates should respect the
original language semantics. However, to perform some trace optimization
(e.g. sinking optimization) this consistency is not respected. Instead
modification that should have occurred during a trace is recorded inside the
snapshots and those modification are replayed at trace exit. The Snapshot
mechanism is implemented in the snap.[hc] files, and you can find the
\emph{SnapShot} data-structure in lj\_jit.h. For details about
Snapshot usages and implementation refer to section of the wiki on sinking
optimization \cite{luajit-sink} and a mail on the subject \cite{luajit-mail-1}.
