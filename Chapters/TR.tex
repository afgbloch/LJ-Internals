%!TEX root = ../FYP_Dissertation.tex

%===============================================================================
% Hot path detection
%===============================================================================

\section{Hot path detection}
\label{Sec:hot-path}

LuaJIT does trace compilation. For that, it needs to detect that a certain
portion of the code gets hot and compile it as a trace. Two types of trace entry
are detected, loops and function. In the vm (See Part \ref{Part:VM}) each
traceable loop-like or call-like BC (bytecode) decrement a low-overhead profile
counter that is at the hashed PC (program counter) position of a 64-entries table.
When the counter underflows, it start recording. Bellow is the call order that
trigger a recording depending of the bytecode. This counter table being small
and collision being ignored false positive may occur.
It must be noted that LuaJIT perform a natural-loop first (NLF) region selection.
This can be noted in two ways. First, when the BC is a loop the counters are
decremented twice as fast as for function call. Second, In most cases, if a
parent trace hit an inner loop, the parent trace is aborted.

\paratitle{Loops:}

\begin{itemize}
	\item \emph{hotloop} : hash the pc, decrement the corresponding counter and
jmp to vm\_hotloop if it underflows (vm\_(arch).dasc).
	\item \emph{vm\_hotloop} : Prepare the stack and call lj\_trace\_hot.
	\item \emph{lj\_trace\_hot} : start recording a trace (lj\_trace.c).
\end{itemize}

\paratitle{Functions:}

\begin{itemize}
	\item \emph{hotcall} : hash the pc, decrement the corresponding counter and
jmp to vm\_hotcall if it underflows (vm\_(arch).dasc).
	\item \emph{vm\_hotcall} : Prepare the stack and call lj\_dispatch\_call.
	\item \emph{lj\_dispatch\_call} : perform initialization
	and call \emph{lj\_trace\_hot} that start recording a trace (lj\_dispatch.c).
\end{itemize}

\emph{lj\_trace\_hot} start the recording of a parent trace by changing
\emph{J$->$state} to \emph{LJ\_TRACE\_START}, starting the recorder state
machine, described in the next section.


%===============================================================================
% Recorder state machine
%===============================================================================

\section{Recorder state machine}
\label{Sec:recorder-state-machine}

Recording is the fact of executing the bytecode while remembering dynamic
data/type and generating on the fly the IR specialized for this recording. In
doing so, the control flow is flattened meaning that only taken branch are
recorded and function call are inlined. The code responsible for that lie in, the
\emph{lj\_trace.c} file for the state machine presented bellow and the helper
functions, the \emph{lj\_record.c} for most of the bytecode recording,
the \emph{lj\_ffrecord.c} for the data of fast function call and
\emph{lj\_crecord.c} for the cdata operations.

\includegraphics[width=\textwidth]{./Images/FSM.pdf}

\begin{table}[H]
\centering
\caption{Library Macro definitions}
\label{tab:library-macro}
\begin{tabularx}{\textwidth}{|c|X|}
\hline
\multicolumn{1}{|c|}{Macro}          & \multicolumn{1}{c|}{Description}                     \\\hline
Start                   &
  \begin{tabular}[c]{@{}l@{}}
  Call trace\_start that perform jit\_State setup and \\allocations.
  Change state to LJ\_TRACE\_RECORD.
  \end{tabular}                                                                             \\\hline
Record                  & Recording in progress. It loop over the
	lj\_record\_ins function, which is a huge switch case that record a specific
  bytecode instruction and generate the corresponding specialized IR code of the
  BC before execution. It is executed inside a pcall and jump to the
  \emph{Error} state if a lua exception is thrown. \\\hline%
End                     &
  End of recording. It applies optimizations on the IR (see Chapter \ref{Chapt:TO}).        \\\hline
ASM                     &
	Assemble the trace and call trace\_stop to patch the BC (see Chapter \ref{Chapt:TA}).     \\\hline
Error                   &
	Abort the recording of the current trace, perform state cleanup, penalize the
	corresponding hot BC or apply blacklisting (see Section \ref{Sec:abort})                  \\\hline
\end{tabularx}
\end{table}

%===============================================================================
% Abortion and blacklisting
%===============================================================================

\section{Abortion and blacklisting}
\label{Sec:abort}

There exist multiple reason that might cause a recording to abort. Such reason
could be that the unroll limit is reached, that the trace is too long, that the
jit is disable for a specific function or many other. (see \emph{lj\_traceerr.h}
for the list of possible abort messages). To trigger an abortion, a lua error is
thrown during the recording which transition the recorder state machine to the
\emph{LJ\_TRACE\_ERR} state. Then, the \emph{penalty\_pc} function is called on
the hot bytecode that triggered the recording. The penalty mechanism consist of
a 64-entry table, where each entry is a structure containing the exact PC of the
penalized bytecode, the penalty value, and the reason of the abortion. The
\emph{penaltyslot} variable is a round-robin index inside the table indicating
the next entry to use if a new bytecode needs to be penalized. It as to be noted
that on the contrary of the hotcount mechanisme, here the full PC is used to
identify a slot making it free of false positive. However, since the entry is
only 64 entry, penalized bytecode can easily be forgotten in a big code base.
If the penalty for a given bytecode exceeds a threshold then the hot bytecode
responsible for starting the recording gets blacklisted. It meaning that this
bytecode can never become hot again to start a recording and that if this
bytecode try to be recorded inside another trace, this trace get aborted too
(in most cases). A blacklisted bytecode is never whitelisted by the system.

%===============================================================================
% Intermediate representation
%===============================================================================

\section{Intermediate representation}
\label{Sec:IR}

% IR:
% ----
% - SSA (Static single assignment) based (cf : https://www.wikiwand.com/en/Static_single_assignment_form)
% - Data-flow for loops is represented using PHI-instructions.
% - Control-flow is always implicit.
% - operands are 16 bit references
% - implemented with a bidirectionally growable array
% - Skip-list chains: The IR is threaded with segregated, per-opcode
%   skip-list chains. The links are stored in a multi-purpose 16 bit
%   field in the instruction. This facilitates low-overhead lookup
%   for CSE, DSE and alias analysis. Back-linking enables short-cut
%   searches (average overhead is less than 1 lookup). Incremental
%   build-up is trivial. No hashes, no sets, no complex updates.
% - a single High-level IR across all optimization stage.
% - Trace IR code is represented as an array in memory.
% - The array includes two different things: instructions and constants.
% - Instructions are stored at "upwards" indices 0,1,2,... ( > 0x8000 )
% - Constants are stored at "downwards" indices -1,-2,-3,... ( < 0x8000 )
% - References to array elements are "biased" by adding 0x8000.
% - ir reference are index in the ir array.
% - Every instruction has an output data type.
% - IR constants are interned and can be compared for equality only by looking at their references.
% - Guarded assertions have a dual purpose
%   - They provide an assertion about their operands.
%   - They are emitted by the backend as branching comparisons,
%     - true ->  fall-through path.
%     - false ->  outcome exits the trace and restores the state using last snapshot.

% -- IR instruction format (64 bit).
% --
% --    16      16     8   8   8   8
% -- +-------+-------+---+---+---+---+
% -- |  op1  |  op2  | t | o | r | s |
% -- +-------+-------+---+---+---+---+
% -- |  op12/i/gco32 |   ot  | prev  | (alternative fields in union)
% -- +-------+-------+---+---+---+---+
% -- |  TValue/gco64                 | (2nd IR slot for 64 bit constants)
% -- +---------------+-------+-------+
% --        32           16      16
% --
% -- prev is only valid prior to register allocation and then reused for r + s.
% --
% -- t    : type
% -- o    : opcode
% -- r    : register allocation
% -- s    : spill slot
% -- prev : chain of instruction of same opcode


%===============================================================================
% Snapshots
%===============================================================================

\section{Snapshots}
\label{Sec:snap}

Snapshot is an important mechanism used in trace compilation. The VM should
always be in a consistent state, meaning that all updates should respect the
original language semantics. However, to perform some trace optimization
(e.g. sinking optimization) this consistency is not respected. Instead
modification that should have occurred during a trace is recorded inside the
snapshots and those modification are replayed at trace exit. The Snapshot
mechanism is implemented in the snap.[hc] files, and you can find the
\emph{SnapShot} data-structure in lj\_jit.h. For details about
Snapshot usages and implementation refer to section of the wiki on sinking
optimization \cite{luajit-sink} and a mail on the subject \cite{luajit-mail-1}.
