%!TEX root = ../FYP_Dissertation.tex

\section{String Internalization}
\label{Sec:string-inter}

All strings that are manipulated by LuaJIT are internalized. This includes, all
the strings literals of the user lua code, all identifier and tokens of the lua
code itself and also all the strings used internally by LuaJIT. Internalization
mechanism does that, only one copy of a specific strings is kept in memory. If
multiple copy of a same string are requested, a pointer to the internalized
version of the string is returned, instead of doing a new string allocation.
Strings need to be immutable and are zero-terminated. Strings function are
implemented in the \emph{lj\_str.c} file and internalization is done by the
\emph{lj\_str\_new} function.

For that, it implements a hash table and use a very sparse but fast hash
function. Collisions are handled by the use of singly-chained linked list.
The table is resized and all string rehashed when a 100\% load is reached.
The necessary states are saved in the \emph{global\_State} structure in the
\emph{lj\_obj.h} file.

\begin{lstlisting}[style=CStyle]
typedef struct global_State {
  GCRef *strhash; /* String hash table (hash chain anchors). */
  MSize strmask;  /* String hash mask (size of hash table - 1). */
  MSize strnum;   /* Number of strings in hash table. */
  [...]
}
\end{lstlisting}

\section{Lua table}
\label{Sec:string-inter}

Tables are garbage collectible objects represented by the structure bellow
(\emph{GCtab} in \emph{lj\_obj.h}). Functions to manipulate them are in
\emph{lj\_tab.c} and \emph{lj\_tab.h} files. It is composed of an array part and
a hash part. If the array part is small, it is allocated directly after the
structure in memory (collocation functionality), otherwise it is separated. The
hash part is a hash table used to store all non-integer key (or integer too big
to fit in the array part). It is implemented has an array using singly-linked
list for collision, where nodes of the linked list are within the array (not
allocated) and a variation of \emph{Brent's hashing methods} is used. When a
resizing occur the hash values are re-hashed and integer key that does fit now
in the array part are reintroduce there. The \emph{nomm} field of GCtab is a
negative cache for fast metamethods checks. It is a bitmap marking absent fields
of the metatable.

\begin{lstlisting}[style=CStyle]
typedef struct GCtab {
  GCHeader;
  uint8_t nomm;    /* Negative cache for fast metamethods. */
  int8_t colo;     /* Array colocation
  (number of slot directly following in memory).*/
  MRef array;      /* Array part. */
  GCRef gclist;
  GCRef metatable; /* Must be at same offset in GCudata. */
  MRef node;       /* Hash part. */
  uint32_t asize;  /* Size of array part (keys [0, asize-1]). */
  uint32_t hmask;  /* Hash part mask (size of hash part - 1). */
#if LJ_GC64
  MRef freetop;    /* Top of free elements. */
#endif
} GCtab;
\end{lstlisting}

