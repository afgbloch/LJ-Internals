%!TEX root = ../FYP_Dissertation.tex

\section{String Internalization}
\label{Sec:string-inter}

All strings that are manipulated by LuaJIT are internalized. This includes, all
the strings literals of the user lua code, all identifier and tokens of the lua
code itself and also all the strings used internally by LuaJIT. Internalization
mechanism does that, only one copy of a specific strings is kept in memory. If
multiple copy of a same string are requested, a pointer to the internalized
version of the string is returned, instead of doing a new string allocation.
Strings need to be immutable and are zero-terminated. Strings function are
implemented in the \emph{lj\_str.c} file and internalization is done by the
\emph{lj\_str\_new} function.

For that, it implements a hash table and use a very sparse but fast hash
function. Collisions are handled by the use of singly-chained linked list.
The table is resized and all string rehashed when a 100\% load is reached.
The necessary states are saved in the \emph{global\_State} structure in the
\emph{lj\_obj.h} file.

\begin{lstlisting}[style=CStyle]
typedef struct global_State {
  GCRef *strhash; /* String hash table (hash chain anchors). */
  MSize strmask;  /* String hash mask (size of hash table - 1). */
  MSize strnum;   /* Number of strings in hash table. */
  [...]
}
\end{lstlisting}

\section{Lua table}
\label{Sec:table}

Tables are garbage collectible objects represented by the structure bellow
(\emph{GCtab} in \emph{lj\_obj.h}). Functions to manipulate them are in
\emph{lj\_tab.c} and \emph{lj\_tab.h} files. It is composed of an array part and
a hash part. If the array part is small, it is allocated directly after the
structure in memory (collocation functionality), otherwise it is separated. The
hash part is a hash table used to store all non-integer key (or integer too big
to fit in the array part). It is implemented has an array using singly-linked
list for collision, where nodes of the linked list are within the array (not
allocated) and a variation of \emph{Brent's hashing methods} is used. When a
resizing occur the hash values are re-hashed and integer key that does fit now
in the array part are reintroduce there. The \emph{nomm} field of GCtab is a
negative cache for fast metamethods checks. It is a bitmap marking absent fields
of the metatable.

\begin{lstlisting}[style=CStyle]
typedef struct GCtab {
  GCHeader;
  uint8_t nomm;    /* Negative cache for fast metamethods. */
  int8_t colo;     /* Array colocation
  (number of slot directly following in memory).*/
  MRef array;      /* Array part. */
  GCRef gclist;
  GCRef metatable; /* Must be at same offset in GCudata. */
  MRef node;       /* Hash part. */
  uint32_t asize;  /* Size of array part (keys [0, asize-1]). */
  uint32_t hmask;  /* Hash part mask (size of hash part - 1). */
#if LJ_GC64
  MRef freetop;    /* Top of free elements. */
#endif
} GCtab;
\end{lstlisting}

\section{Garbage collector}
\label{Sec:gc}

LuaJIT garbage collector has currently a tri-color, incremental mark and sweep
types implementation. You can find a presentation of it on the wiki
\cite{luajit-gc} in the tri-color section. Its source code can be found in the
\emph{lj\_gc.h} and \emph{lj\_gc.c} files. It uses the GCState structure has a
principal structure. The \emph{gc\_onestep} function is the principal one as it
implement the stat machine of the gc. Principal state with their meaning can be
found in the enum bellow.

\begin{lstlisting}[style=CStyle]
enum {
  GCSpause,
  GCSpropagate,   /* One gray object is processed. */
  GCSatomic,      /* Atomic transition from mark to sweep phase. */
  GCSsweepstring, /* Sweep one chain of strings from the table. */
  GCSsweep,       /* Sweep a few object from root. */
  GCSfinalize     /* Finalize one userdata or cdata object. */
};
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
typedef struct GCState {
  GCSize total;         /* Memory currently allocated. */
  GCSize threshold;     /* Memory threshold. */
  uint8_t currentwhite; /* Current white color. */
  uint8_t state;        /* GC state. */
  uint8_t nocdatafin;   /* No cdata finalizer called. */
  uint8_t unused2;
  MSize sweepstr;       /* Sweep position in string table. */
  GCRef root;           /* List of all collectable objects. */
  MRef sweep;           /* Sweep position in root list. */
  GCRef gray;           /* List of gray objects. */
  GCRef grayagain;      /* List of objects for atomic traversal. */
  GCRef weak;           /* List of weak tables (to be cleared). */
  GCRef mmudata;        /* List of userdata (to be finalized). */
  GCSize debt;          /* Debt (how much GC is behind schedule). */
  GCSize estimate;      /* Estimate of memory actually in use. */
  MSize stepmul;        /* Incremental GC step granularity. */
  MSize pause;          /* Pause between successive GC cycles. */
} GCState;
\end{lstlisting}

\section{Function}
\label{Sec:func}

There are two distinct representation for function, the function's prototype,
and the function's closure. the Lua functions' prototypes are represented by \emph{GCproto} (\emph{lj\_obj.h}), and are followed by the functions' bytecodes in memory.
The closures are represented by the GCfuncL for lua function and GCfuncC for
c function (using lua's api). They contains the necessary information for
upvalues. Upvalues are represented by the \emph{GCupval} that if close, contains
the corresponding value or a reference to the stack slot containing the
appropriate value otherwise. Closure can be manage by the functions present in
\emph{lj\_func.c} allowing to create them, destroy them and closing their
upvalues.

\begin{lstlisting}[style=CStyle]
typedef struct GCproto {
  GCHeader;
  uint8_t numparams; /* Number of parameters. */
  uint8_t framesize; /* Fixed frame size. */
  MSize sizebc;      /* Number of bytecode instructions. */
  [...]
  GCRef gclist;
  MRef k;            /* Split constant array (ptr to the middle).*/
  MRef uv;           /* Upvalue list. local slot or parent uv idx. */
  MSize sizekgc;     /* Number of collectable constants. */
  MSize sizekn;      /* Number of lua_Number constants. */
  MSize sizept;      /* Total size including colocated arrays. */
  uint8_t sizeuv;    /* Number of upvalues. */
  uint8_t flags;     /* Miscellaneous flags. */
  uint16_t trace;    /* Anchor for chain of root traces. */
  [...]
} GCproto;
\end{lstlisting}
