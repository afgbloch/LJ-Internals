%!TEX root = ../FYP_Dissertation.tex

We can differentiate in the code, three types of optimizations.
First of all there are the optimizations present in the optimization engine.
They are implemented in the \emph{lj\_opt\_*.c} files and thus easy to spot out.
Those optimization are of two kind, global optimization that are run on the
entire IR at once at the end of the recording phase (See \ref{Sec:opt-dce}, \ref{Sec:opt-loop}, \ref{Sec:opt-split}, \ref{Sec:opt-sinking}) and the local
optimizations that are applied while recording a trace (See \ref{Sec:narrowing},
\ref{Sec:mao}, \ref{Sec:fold}).
Finally, there is a plethora of optimization and heuristic applied here and
there (See ).\todo{add references}
% ------------------------------------------------------------------------------
% Optimization Engine : Global Optimizations (end of recording phase)
% ------------------------------------------------------------------------------

%===============================================================================
% TODO
%===============================================================================

\section{Dead code elimination}
\label{Sec:opt-dce}

\section{Loop optimizations}
\label{Sec:opt-loop}

\section{Split optimizations}
\label{Sec:opt-split}

\section{Sinking optimizations}
\label{Sec:opt-sinking}
This a very useful optimization that allows to avoid many temporaries and
unnecessary memory accesses and allocations by keeping the values of interest
directly in register. We thus have to remember how the memory should have been
modified in case those access escape our execution path (are not temporary
anymore), for this purpose snapshot are used (See Section \ref{Sec:ir-snap}). This optimization is implemented
in the \emph{lj\_opt\_sink.c} file. A detailed explanation of this optimization
is available on the wiki \cite{luajit-sink}.


% ------------------------------------------------------------------------------
% Optimization Engine : Local Optimizations (During recording phase)
% ------------------------------------------------------------------------------

\section{Narrowing optimizations}
\label{Sec:narrowing}

\section{Memory access optimizations}
\label{Sec:mao}

\section{Fold optimizations}
\label{Sec:fold}

% ------------------------------------------------------------------------------
% Embeded Optimizations
% ------------------------------------------------------------------------------



% ================================================================================
% ================================================================================
% Optimizations:
% --------------
% during LJ_TRACE_END state the following optimizations function are called
%   - lj_opt_dce: perform dce optimization
%   - lj_opt_loop:
%   - lj_opt_split:
%   - lj_opt_sink:
% - dce (dead code elimination) (2)
%   - in lj_opt_dce
%   - Pre-LOOP only - ASM already performs DCE.
%   - performed durring trace end.
%   - performed in two phases
%     - 1st: called mark snap mark all ir reference in snapshots
%     - 2nd: called propagate that iteratively mark operands of maked ir
%     and replace non-marked ir by nop isftructions.
% - loop optimizations (3) (add a trace dump or images to illustrate this
%   - Code hoisting via unrolling and copy-substitution (LOOP):
%     Traditional loop-invariant code motion (LICM) is mostly useless
%     for the IR resulting from dynamic languages. The IR has many
%     guards and most subsequent instructions are control-dependent on
%     them. The first non-hoistable guard would effectively prevent
%     hoisting of all subsequent instructions.

%     The LOOP pass does synthetic unrolling of the recorded IR,
%     combining copy-substitution with redundancy elimination to
%     achieve code hoisting. The unrolled and copy-substituted
%     instructions are simply fed back into the compiler pipeline,
%     which allows reuse of all optimizations for redundancy
%     elimination. Loop recurrences are detected on-the-fly and a
%     minimized set of PHIs is generated.

%   -- That's why we use a special form of unrolling using copy-substitution,
%   -- combined with redundancy elimination:
%   --
%   -- The recorded instruction stream is re-emitted to the compiler pipeline
%   -- with substituted operands. The substitution table is filled with the
%   -- refs returned by re-emitting each instruction. This can be done
%   -- on-the-fly, because the IR is in strict SSA form, where every ref is
%   -- defined before its use.
%   --
%   -- This aproach generates two code sections, separated by the LOOP
%   -- instruction:
%   --
%   -- 1. The recorded instructions form a kind of pre-roll for the loop. It
%   -- contains a mix of invariant and variant instructions and performs
%   -- exactly one loop iteration (but not necessarily the 1st iteration).
%   --
%   -- 2. The loop body contains only the variant instructions and performs
%   -- all remaining loop iterations.

% - split optimizations (only for 32bits architecture)
% - sink optimizations
% - Fold optimizations:(lj_opt_fold.c) (1)
%   lj_foldef.h is generated by buildvm_fold.c at compile time (see build lib section).
%   rules are declared using the LJFOLD macro they contains the ir opcode and a rule
%   on the parametters it applies to.
%   lj_opt_fold is the engine (main) function.
%   -- Every entry in the generated hash table is a 32 bit pattern:
%   --
%   -- xxxxxxxx iiiiiii lllllll rrrrrrrrrr
%   --
%   --   xxxxxxxx = 8 bit index into fold function table
%   --    iiiiiii = 7 bit folded instruction opcode
%   --    lllllll = 7 bit left instruction opcode
%   -- rrrrrrrrrr = 8 bit right instruction opcode or 10 bits from literal field
%   lj_opt_fold.c:
%     - constant folding
%     - algebraic simplifications
%     - reassociation
%     - common subexpression elimination
%     - Array bounds check elimination
%   lj_opt_mem.c: Memory access optimizations
%     - AA  : Alias Analysis using high-level semantic disambiguation.
%     - FWD : Load Forwarding (L2L) + Store Forwarding (S2L).
%     - DSE : Dead-Store Elimination.
%   lj_opt_narrow.c:
%     - narrowing
%   - Rule-based FOLD engine: The FOLD engine is primarily used for
%     constant folding, algebraic simplifications and reassociation.
%     Most traditional compilers have an evolutionary grown set of
%     implicit rules, spread over thousands of hand-coded tiny
%     conditionals.

%     The rule-based FOLD engine uses a declarative approach to
%     combine the first and second level of lookup. It allows wildcard
%     lookup with masked keys, too. A pre-processor generates a
%     semi-perfect hash table for constant-time rule lookup. It''s able
%     to deal with thousands of rules in a uniform manner without
%     performance degradation. A declarative approach is also much
%     easier to maintain.
% -  Narrowing optimizations
%   - Narrowing of numbers to integers: Predictive narrowing is used
%     for induction variables. Demand-driven narrowing is used for
%     index expressions using a backpropagation algorithm.

%     This avoids the complexity associated with speculative, eager
%     narrowing, which also causes excessive control-flow dependencies
%     due to the many overflow checks. Selective narrowing is better
%     at exploiting the combined bandwidth of the FP and integer units
%     of the CPU and avoids clogging up the branch unit.
% ================================================================================
% ================================================================================
