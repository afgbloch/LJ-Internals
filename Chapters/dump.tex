%!TEX root = ../FYP_Dissertation.tex
\section{How to use it}
\label{Sec:dump-usage}
This module can be used to debug the JIT compiler itself. It dumps the
code representations and structures used in various compiler stages.

Example usage:
\begin{lstlisting}
  luajit -jdump -e "
    local x=0
    for i=1,1e6 do x=x+i end
    print(x)
  "
  luajit -jdump=im -e "
    for i=1,1000 do
      for j=1,1000 do end
    end
  " | less -R
  luajit -jdump=is myapp.lua | less -R
  luajit -jdump=-b myapp.lua
  luajit -jdump=+aH,myapp.html myapp.lua
  luajit -jdump=ixT,myapp.dump myapp.lua
\end{lstlisting}
The first argument specifies the dump mode. The second argument gives
the output file name. Default output is to stdout, unless the environment
variable LUAJIT\_DUMPFILE is set. The file is overwritten every time the
module is started. Different features can be turned on or off with the dump mode.
If the mode starts with a '+', the following features are added to the default
set of features; a '-' removes them. Otherwise the features are replaced.\\
The following dump features are available (* marks the default):

\begin{itemize}
  \item \textbf{t *} - Print a line for each started, ended or aborted trace (see also -jv).
  \item \textbf{b *} - Dump the traced bytecode.
  \item \textbf{i *} - Dump the IR (intermediate representation).
  \item \textbf{r} - Augment the IR with register/stack slots.
  \item \textbf{s} - Dump the snapshot map.
  \item \textbf{m *} - Dump the generated machine code.
  \item \textbf{x} - Print each taken trace exit.
  \item \textbf{X} - Print each taken trace exit and the contents of all registers.
  \item \textbf{a} - Print the IR of aborted traces, too.
\end{itemize}
The output format can be set with the following characters:
\begin{itemize}
   \item \textbf{T} - Plain text output.
   \item \textbf{A} - ANSI-colored text output
   \item \textbf{H} - Colorized HTML + CSS output.
\end{itemize}
The default output format is plain text. It's set to ANSI-colored text
if the COLORTERM variable is set.

\section{Understanding states dump}
\label{Sec:dump-states}
This command looks like the verbose mode (-jv) and print informations for each start,
end or abortion of a trace. The output can have one of those three shapes.\\
---- TRACE 1 start foo.lua:125\\
---- TRACE 1 stop -\textgreater [link]\\
---- TRACE 1 abort foo.lua:142 -- [message]\\
The first one is emitted when a recording starts. It shows the potential
trace number, the file and the source line where that trace start.
The second one is emitted when a trace has been successfully recorded. In
addition of the trace number, it shows to what the trace link to (See Table
\ref{tab:dump-link} for [link] possible values). Finally the last one is emitted
when the recording of a trace is aborted. It shows the file and the source line
responsible for the abortion and print a [message] depicting the reason. For
a list of possible messages see TraceError in lj\_trace.h and macro in
lj\_traceerr.h.

\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
\multicolumn{1}{|c|}{value} & \multicolumn{1}{c|}{Meaning}\\\hline
none                        & Incomplete trace. No link, yet.\\
root                        & Link to other root trace.\\
loop                        & Loop to same trace.\\
tail-recursion              & Tail-recursion.\\
up-recursion                & Up-recursion.\\
down-recursion              & Down-recursion.\\
interpreter                 & Fallback to interpreter.\\
return                      & Return to interpreter.\\
stitch                      & race stitching.\\\hline
\end{tabular}
\caption{
  Possible value for [link] \\(See jit\_trlinkname and TraceLink in lib\_jit.c
  and lj\_jit.h)
}
\label{tab:dump-link}
\end{table}


\paratitle{Side trace}\\
% ---- TRACE 30 start 21/0 subObject.lua:103
% this is how a side trace is shown
%   - 30 : trace number
%   - 21 : parent number
%   - 0  : exit number inside parent trace

\paratitle{Stitching}\\
% Trace stitching is feature which allows traces to stop at a classic C function
% or a not-compiled built-in, return to the interpreter, run the C function or
% built-in and then start a new trace after it returns.
% eg:
%   ---- TRACE 29 start 25/0 subObject.lua:6
%     [...]
%     0000  . FUNCC               ; os.clock (not compiled)
%   ---- TRACE 29 stop -> stitch
%   ---- TRACE 33 start 29/stitch subObject.lua:335


\section{Understanding BC dump}
\label{Sec:dump-bc}

\section{Understanding IR dump}
\label{Sec:dump-ir}

\section{Understanding mcode dump}
\label{Sec:dump-mcode}

\section{How does it works}
\label{Sec:dump-internals}

