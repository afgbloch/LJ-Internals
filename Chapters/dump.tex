%!TEX root = ../FYP_Dissertation.tex
\section{How to use it}
\label{Sec:dump-usage}
This module can be used to debug the JIT compiler itself. It dumps the
code representations and structures used in various compiler stages.

Example usage:
\begin{lstlisting}
  luajit -jdump -e "
    local x=0
    for i=1,1e6 do x=x+i end
    print(x)
  "
  luajit -jdump=im -e "
    for i=1,1000 do
      for j=1,1000 do end
    end
  " | less -R
  luajit -jdump=is myapp.lua | less -R
  luajit -jdump=-b myapp.lua
  luajit -jdump=+aH,myapp.html myapp.lua
  luajit -jdump=ixT,myapp.dump myapp.lua
\end{lstlisting}
The first argument specifies the dump mode. The second argument gives
the output file name. Default output is to stdout, unless the environment
variable LUAJIT\_DUMPFILE is set. The file is overwritten every time the
module is started. Different features can be turned on or off with the dump mode.
If the mode starts with a '+', the following features are added to the default
set of features; a '-' removes them. Otherwise the features are replaced.\\
The following dump features are available (* marks the default):

\begin{itemize}
  \item \textbf{t *} - Print a line for each started, ended or aborted trace (see also -jv).
  \item \textbf{b *} - Dump the traced bytecode.
  \item \textbf{i *} - Dump the IR (intermediate representation).
  \item \textbf{r} - Augment the IR with register/stack slots.
  \item \textbf{s} - Dump the snapshot map.
  \item \textbf{m *} - Dump the generated machine code.
  \item \textbf{x} - Print each taken trace exit.
  \item \textbf{X} - Print each taken trace exit and the contents of all registers.
  \item \textbf{a} - Print the IR of aborted traces, too.
\end{itemize}
The output format can be set with the following characters:
\begin{itemize}
   \item \textbf{T} - Plain text output.
   \item \textbf{A} - ANSI-colored text output
   \item \textbf{H} - Colorized HTML + CSS output.
\end{itemize}
The default output format is plain text. It's set to ANSI-colored text
if the COLORTERM variable is set.

\section{Understanding states dump}
\label{Sec:dump-states}
This command looks like the verbose mode (-jv) and print informations for each start,
end or abortion of a trace. The output can have one of those three shapes.
\begin{verbatim}
---- TRACE 1 start foo.lua:125
---- TRACE 1 stop -> [link]
---- TRACE 1 abort foo.lua:142 -- [message]
\end{verbatim}
The first one is emitted when a recording starts. It shows the potential
trace number, the file and the source line where that trace start.
The second one is emitted when a trace has been successfully recorded. In
addition of the trace number, it shows to what the trace link to (See Table
\ref{tab:dump-link} for [link] possible values). Finally the last one is emitted
when the recording of a trace is aborted. It shows the file and the source line
responsible for the abortion and print a [message] depicting the reason. For
a list of possible messages see TraceError in lj\_trace.h and macro in
lj\_traceerr.h.

\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
\multicolumn{1}{|c|}{value} & \multicolumn{1}{c|}{Meaning}\\\hline
none                        & Incomplete trace. No link, yet.\\
root                        & Link to other root trace.\\
loop                        & Loop to same trace.\\
tail-recursion              & Tail-recursion.\\
up-recursion                & Up-recursion.\\
down-recursion              & Down-recursion.\\
interpreter                 & Fallback to interpreter.\\
return                      & Return to interpreter.\\
stitch                      & race stitching.\\\hline
\end{tabular}
\caption{
  Possible value for [link] \\(See jit\_trlinkname and TraceLink in lib\_jit.c
  and lj\_jit.h)
}
\label{tab:dump-link}
\end{table}


\paratitle{Side trace}\\
When instruction of a trace marked as guard fail, the normal execution of a
trace is interrupted. We then call that spot a side exit of the trace. When a
given side exit is taken enough time, it is said to be hot and generate a new
trace starting from it. This new trace is called a side trace of the first one
called the parent trace. Bellow is how the start of the recording of a side
trace is shown in the dump.
\begin{verbatim}
---- TRACE 30 start 21/0 foo.lua:103
\end{verbatim}
Here 30 is the side trace number, 21 the parent trace from witch the side trace
start from and 0 is the side exit number.

\paratitle{Stitching}\\
Trace stitching is feature which allows traces to stop at a classic C function
or a not-compiled built-in, return to the interpreter, run the C function or
built-in and then start a new trace after it returns. Bellow is an example of
how trace stitching due to a not-compiled built-in can be shown in the dump.
\begin{verbatim}
---- TRACE 1 start foo.lua:6
  [...]
  0000  . FUNCC               ; os.clock
---- TRACE 1 stop -> stitch
---- TRACE 2 start 1/stitch foo.lua:35
\end{verbatim}
As you can see the trace prior to the stitching has its link marked as
\emph{stitch} and the one after is shown like a side trace but with
\emph{stitch} instead of the number of the side exit.

\section{Understanding BC dump}
\label{Sec:dump-bc}
Bellow is a example of how a BC instruction is shown in the dump. For a complete
list of BC instruction and their corresponding arguments look at the wiki page
\cite{luajit-bc}.
\begin{verbatim}
0007  . . CALL     2   2   2  ;comment
\end{verbatim}
\begin{itemize}
  \item 1st column : bc number, numbered by function.
  \item 2nd column : The dots represent the depth (call hierarchy).
  \item 3rd column : bc instruction.
  \item other-1... : bc arguments.
  \item last       : comment helping to tie the instruction to the lua code.
\end{itemize}

\section{Understanding IR dump}
Bellow are some example of dumps of IR instructions.
\label{Sec:dump-ir}
\begin{verbatim}
0001 rax   >  tab SLOAD  #46   T
0014 rbp      int TOBIT  0005  bias
0040 [1c]  >  tab HLOAD  0039
0035  {sink}+ cdt CNEW   +16
0023  {0021}  num XSTORE 0022  0018
0155       >  p32 HREFK  0154  "assert" @131
0159       >  fun EQ     0158  madl_gutil.mad:298
\end{verbatim}

\begin{itemize}
  \item 1st column: IR instruction number (numbered per trace)
  \item 2nd column: Show where the value is written to when converted to machine
    code. This column is only present if the 'r' flags is included in -jdump,
    which augments the IR with register/stack slots. It is not part of the IR
    itself.
    \begin{itemize}
      \item '\%w' : physical CPU register
      \item '[\%d+]' : physical CPU stack slot (hexadecimal offset from stack pointer).
      \item \{sink\} : Show when a \emph{sink} optimization occur.
      \item \{\%d+\} : Refers to the IR instruction where a \emph{sink}
        optimization occur.
    \end{itemize}
  \item 3nd column: Instruction flags (See lj\_ir.h)
  \begin{itemize}
    \item "\textgreater" (IRT\_GUARD) are locations of
        guards (leading to possible side exits from the trace).
    \item "+" (IRT\_ISPHI) indicates
        instruction is left or right PHI operand. (i.e referred
        to in some PHI instruction).
  \end{itemize}
  \item 4rd column: IR type.
  \item 5th column: IR opcode.
  \item 6th/7th column: IR operands
    \begin{itemize}
      \item '\%d+' : reference to IR instruction (SSA ref).
      \item '\#' : prefixes refer to slot numbers, used in SLOADS.
        \#0 is the base frame (modified only in tail calls).
        \#1 is the first slot in the first frame (register 0 in
        the bytecode).
      \item '(+$\vert$-)\%d+' : prefixes indicate positive or negative numeric literals.
      \item '[0x\%d+]$\vert$NULL' : memory addresses.
      \item '"..."' : strings.
      \item '@\%d+' : indicate slot where the value of a key is to be found (in a table).
      \item 'bias' : Used by \emph{TOBIT} represent the constant
        $2^{52}+2^{51}$ added to the FP number.
      \item \{0x\%d+\} : lua table.
      \item 'userdata:\%p' : user data.
      \item 'my\_func:ligne' : functions.
      \item '(...)' : function arguments for call-type IR.
    \end{itemize}
\end{itemize}

\begin{table}
\centering
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{SLOAD}\\\hline
P & PARENT    & Coalesce with parent trace.\\
F & FRAME     & Load 32 bits of ftsz.\\
T & TYPECHECK & Needs type check.\\
C & CONVERT   & Number to integer conversion.\\
R & READONLY  & Read-only, omit slot store.\\
I & INHERIT   & Inherited by exits/side traces.\\
\hline
\end{tabular}
\end{table}
\begin{table}
\centering
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{XLOAD}\\\hline
R & READONLY  & Load from read-only data.\\
V & VOLATILE  & Load from volatile data.\\
U & UNALIGNED & Unaligned load.\\
\hline
\end{tabular}
\end{table}
\begin{table}
\centering
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{FLOAD or FREF}\\\hline
str.len        & IRFL\_STR\_LEN        & \\
func.env       & IRFL\_FUNC\_ENV       & \\
func.pc        & IRFL\_FUNC\_PC        & \\
func.ffid      & IRFL\_FUNC\_FFID      & Function id\\
thread.env     & IRFL\_THREAD\_ENV     & \\
tab.meta       & IRFL\_TAB\_META       & \\
tab.array      & IRFL\_TAB\_ARRAY      & \\
tab.node       & IRFL\_TAB\_NODE       & Hash part\\
tab.asize      & IRFL\_TAB\_ASIZE      & Size of array part\\
tab.hmask      & IRFL\_TAB\_HMASK      & Size of hash part - 1\\
% \multirow{2}{*}{tab.nomm\\} & \multirow{2}{*}{IRFL\_TAB\_NOMM} & \multirow{2}{*}{Negative cache for fast metamethods bitmap marking absent fields of the metatable}\\
\multirow{3}{*}{tab.nomm} & \multirow{3}{*}{IRFL\_TAB\_NOMM} & Negative cache for fast \\
& & metamethods bitmap, marking\\
& & absent fields of the metatable\\
udata.meta     & IRFL\_UDATA\_META     & \\
udata.udtype   & IRFL\_UDATA\_UDTYPE   & See UDTYPE table\\
udata.file     & IRFL\_UDATA\_FILE     & udata payload \\
cdata.ctypeid  & IRFL\_CDATA\_CTYPEID  & \\
cdata.ptr      & IRFL\_CDATA\_PTR      & cdata payload \\
cdata.int      & IRFL\_CDATA\_INT      & cdata payload \\
cdata.int64    & IRFL\_CDATA\_INT64    & cdata payload \\
cdata.int64\_4 & IRFL\_CDATA\_INT64\_4 & cdata payload \\
\hline
\end{tabular}
\end{table}
\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{UDTYPE}\\\hline
UDTYPE\_USERDATA  & Regular userdata.\\
UDTYPE\_IO\_FILE  & I/O library FILE.\\
UDTYPE\_FFI\_CLIB & FFI C library namespace.\\\hline
\end{tabular}
\end{table}
\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{FPMATH}\\\hline
floor & FPM\_FLOOR \\
ceil  & FPM\_CEIL  \\
trunc & FPM\_TRUNC \\
sqrt  & FPM\_SQRT  \\
exp   & FPM\_EXP   \\
exp2  & FPM\_EXP2  \\
log   & FPM\_LOG   \\
log2  & FPM\_LOG2  \\
log10 & FPM\_LOG10 \\
sin   & FPM\_SIN   \\
cos   & FPM\_COS   \\
tan   & FPM\_TAN   \\
\hline
\end{tabular}
\end{table}
\begin{table}
\centering
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{BUFHDR}\\\hline
IRBUFHDR\_RESET  & Reset buffer \\
IRBUFHDR\_APPEND & Append to buffer \\
\hline
\end{tabular}
\end{table}
\begin{table}
\centering
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{3}{|c|}{TOSTR}\\\hline
INT  & IRTOSTR\_INT  & Convert integer to string.  \\
NUM  & IRTOSTR\_NUM  & Convert number to string.  \\
CHAR & IRTOSTR\_CHAR & Convert char value to string.  \\\hline
\end{tabular}
\end{table}

\paratitle{Snapshot}\\
Each snaphot (SNAP), lists the modified stack slots and the corresponding values.
Bellow are two examples of how snapshots are shown in ir dump. For further
comments on why snapshots is used, see \todo{add ref}.
\begin{verbatim}
....    SNAP   #1   [ ---- ---- ---- ---- 0069 0070 0071 ---- ]
....    SNAP   #1   [ foo.lua:120|---- ---- false ]
\end{verbatim}
The i-th value in the snapshot list represents the IR instruction number of the
instruction that wrote a value in slot number i. '- - - -' indicates that the slot
has not been modified. Function frames are separated by '$\vert$'.


\section{Understanding mcode dump}
\label{Sec:dump-mcode}

\section{How does it works}
\label{Sec:dump-internals}

