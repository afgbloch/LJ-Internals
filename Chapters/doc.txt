================================================================================
Interesting LuaJIT Presentation: https://mrale.ph/talks/vmss16/#/
================================================================================
lj_ffrecord.c: records data for fast functions
lj_crecord.c: records C data ops
================================================================================
-JBC
0006 => UGET     2   0      ; find
 - 1st column : bc number
 - 2nd column : branch targets of a function
 - 3rd column : bc instruction
 - other-1... : bc arguments
 - last       : comment corresponding lua code
================================================================================
JIT
- lj_trace.c
  - trace_state : State machine for the trace compiler.
    - LJ_TRACE_START : start recording (call to trace_start).
    - LJ_TRACE_RECORD : recording in process.
    - LJ_TRACE_END : end of recording + apply optimizations on IR.
    - LJ_TRACE_ASM : assemble the trace.
    - LJ_TRACE_ERR : abort (trace_abort).
  - trace_start
  - trace_stop
  - trace_abort
================================================================================
- Trace IR code is represented as an array in memory.
- The array includes two different things: instructions and constants.
- Instructions are stored at "upwards" indices 0,1,2,...
- Constants are stored at "downwards" indices -1,-2,-3,...
- References to array elements are "biased" by adding 0x8000.
================================================================================
Programming advice:
  1) for i=1,#s do end
  2) for v in ipairs(s) do end
1) is better in terms of performance. (to be confirmed)
                        **************************
Jitting start always jiting the inner loop first
                        **************************
When starting a record hotcount is reseted even if trace endup aborted.
                        **************************
Indexing a table with a string should be as fast as with a reference (table).
================================================================================
- check if vector size can go down -> yes
- check hypothesis of pairs ? -> vector first, hash part second
- check '?' in error messages (table.insert, table.remove, band) (builtin vs functions)
- Where does the limit of 65000 identifier per chunk comes from.
================================================================================
traces can have flow controle ? (if statement ?)
  -> NO only implicitly : guards break the trace and restore the closest snapshot.
================================================================================
- jflush option : does it mean that codes can be keept from a run to the other ?
================================================================================
- make a GCObj never collectable by gc.
- why allocator is global ? -> It is not :)
- does gc goes through the lua stack.
================================================================================