================================================================================
Interesting LuaJIT Presentation: https://mrale.ph/talks/vmss16/#/
================================================================================
-JBC
0006 => UGET     2   0      ; find
 - 1st column : bc number
 - 2nd column : branch targets of a function
 - 3rd column : bc instruction
 - other-1... : bc arguments
 - last       : comment corresponding lua code
================================================================================
 - there exist two types of trace
   - parent trace ->
   - side trace (recursive) ?? ->
================================================================================
Paragraph on flush policies ??
================================================================================
how can we intern lua table slot in traces.
================================================================================
Programming advice:
  1) for i=1,#s do end
  2) for v in ipairs(s) do end
1) is better in terms of performance. (to be confirmed)
                        **************************
Jitting start always jiting the inner loop first
                        **************************
When starting a record hotcount is reseted even if trace endup aborted.
                        **************************
Indexing a table with a string should be as fast as with a reference (table).
================================================================================
- check if vector size can go down -> yes
- check hypothesis of pairs ? -> vector first, hash part second
- check '?' in error messages (table.insert, table.remove, band) (builtin vs functions)
- Where does the limit of 65000 identifier per chunk comes from.
================================================================================
traces can have flow controle ? (if statement ?)
  -> NO only implicitly : guards break the trace and restore the closest snapshot.
================================================================================
- jflush option : does it mean that codes can be keept from a run to the other ?
================================================================================
- make a GCObj never collectable by gc.
- why allocator is global ? -> It is not :)
- does gc goes through the lua stack.
================================================================================
- jit.flush doesn''t remove blacklistings
- function that ends by a c api/ffi tail-call can not be compile in standalone.
  - potential solution is wrapping return value with ().
- lua_setmetatable run flushall mcode because cdata metatamethode lookup is specialise
  metatable is immutable.
- does jit.on remove the blacklist of a given function ? -> yes
- Inject changes after the first test failed:
  - white list only doesn''t work
  - white list + clear penalty cache doesn''t work
  - white list + clear penalty cache + clear hotcount +
    clear J->prngstate doesn''t work
  - white list + flush does cure the problem
  - flush only does cure the problem (normal ???)
- No performance loss if flushall remove blacklisting
================================================================================
  - LJ_PRNG_BITS in lj_jit.h for penalty used for penalty randomization.
================================================================================
LuaJIT Multithreading:
----------------------
GG_State     : Global state, main thread and extra fields are allocated together.
global_State : Global state, shared by all threads of a Lua universe.

(see also lj_state.h, lj_state.c)

lua_open <=> luaL_newstate : create a fully separate LuaJIT with everything separated
  - allocator
  - garbage collector
  - GG_State
  - global_State
  - Jit_state
================================================================================
Loom: Mostly usefull to use hypetext link to navigate between traces
-----
- launch loom programmatically
  local loom = require"ljit_loom"
  local tmpl = loom.template("loom.html")
  loom.on()
  local out  = loom.off(tmpl)
  local file = assert(io.open("report.html", "w"))
  file:write(out)
  file:close()
- launch loom through the command line
  rlwrap ./mad -jloom=,out.html test.lua
NB:
  - flushs make loom crash (tmp fix)
  - MAD.tostring export (in all.mad) makes loom crash
================================================================================
- function call are always inlined into the trace when possible
  - need to be verified ?
  - what are the conditions ?
================================================================================
- Controle flow is strictly linear (no branch inside a trace)
================================================================================
- Use the model object for has a full example
================================================================================
- lookup the same constant keys in hashtables of many different shapes and sizes
is bad !!!!
================================================================================
https://github.com/lukego/blog/issues/28
================================================================================
Advice for Report: (brain dump)
------------------
- focus on explaining from context -> through mad
- talk about different version of the model object
- trace explosion
- talk about performance in matrix ffi.cast and issues with the gc.
- talk about gc64 mode
------------------
- profiler issues (if times ???)
- add a section on RaptorJIT
- gdb
------------------
- talk about collision in hot detection (run dependent)
- talk about permanent blacklisting
- talk about dumps
- a big part on luajit (overall, scheamatic of luajit)
- keep the detailed ans structured LuaJIT doc in annexe (?)
- a big part on why mad
- tiny talk about madx -> mad-ng
- talk about the miss of tools
- talk about the miss of predictabilty
- talk about sequence, element, tracking, survey, model object
- say that annex took a lot of time (no documentation existing)
- talk about instability
================================================================================
