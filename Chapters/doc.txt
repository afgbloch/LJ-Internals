lj_ffrecord.c: records data for fast functions
lj_crecord.c: records C data ops
================================================================================
-JBC
0006 => UGET     2   0      ; find
 - 1st column : bc number
 - 2nd column : branch targets of a function
 - 3rd column : bc instruction
 - other-1... : bc arguments
 - last       : comment corresponding lua code
================================================================================
JIT
- lj_trace.c
  - trace_state : State machine for the trace compiler.
    - LJ_TRACE_START : start recording (call to trace_start).
    - LJ_TRACE_RECORD : recording in process.
    - LJ_TRACE_END : end of recording + apply optimizations on IR.
    - LJ_TRACE_ASM : assemble the trace.
    - LJ_TRACE_ERR : abort (trace_abort).
  - trace_start
  - trace_stop
  - trace_abort
================================================================================
- Trace IR code is represented as an array in memory.
- The array includes two different things: instructions and constants.
- Instructions are stored at "upwards" indices 0,1,2,...
- Constants are stored at "downwards" indices -1,-2,-3,...
- References to array elements are "biased" by adding 0x8000.
================================================================================
Programming advice:
  1) for i=1,#s do end
  2) for v in ipairs(s) do end
1) is better in terms of performance. (to be confirmed)
                        **************************
Jitting start always jiting the inner loop first
                        **************************
When starting a record hotcount is reseted even if trace endup aborted.
                        **************************
Indexing a table with a string should be as fast as with a reference (table).
================================================================================
- check if vector size can go down -> yes
- check hypothesis of pairs ? -> vector first, hash part second
- check '?' in error messages (table.insert, table.remove, band) (builtin vs functions)
- Where does the limit of 65000 identifier per chunk comes from.
================================================================================
traces can have flow controle ? (if statement ?)
  -> NO only implicitly : guards break the trace and restore the closest snapshot.
================================================================================
- jflush option : does it mean that codes can be keept from a run to the other ?
================================================================================
ffi (cdata):
------------
lib_ffi.c:
  FFI library.
lj_carith:
  C data arithmetic.
lj_ccall:
  FFI C call handling.
lj_ccallback:
  FFI C callback handling.
lj_cconv:
  C type conversions.
lj_cdata:
  C data management.
lj_clib:
  FFI C library loader.
lj_cparse:
  C declaration parser.
lj_ctype:
  C type management.

lib_ffi.c:
----------
- all finilizer are stored in a weak keyed table stored in CTState.
- standart lua api for the ffi library is implemented in lib_ffi.c

Official Doc:
-------------
- http://luajit.org/ext_ffi.html           : motivation and use
- http://luajit.org/ext_ffi_tutorial.html  : small tutorial
- http://luajit.org/ext_ffi_api.html       : FFI api documutation
- http://luajit.org/ext_ffi_semantics.html : FFI Semantics
Unofficial links:
- https://github.com/corsix/ffi-reflect    : reflection library for ctypes
- http://corsix.github.io/ffi-reflect      : related doc

lj_ctype.h:
-----------
- ctype struct
  typedef struct CType {
    CTInfo info;    /* Type info. */
    CTSize size;    /* Type size or other info. */
    CTypeID1 sib;   /* Sibling element. */                (struct field, function argument, enum field)
    CTypeID1 next;  /* Next element in hash chain. */
    GCRef name;     /* Element name (GCstr). */
  } CType;

typedef struct CTState {
  CType *tab;         /* C type table. */
  CTypeID top;        /* Current top of C type table. */
  MSize sizetab;      /* Size of C type table. */
  lua_State *L;       /* Lua state (needed for errors and allocations). */
  global_State *g;    /* Global state. */
  GCtab *finalizer;   /* Map of cdata to finalizer. */
  GCtab *miscmap;     /* Map of -CTypeID to metatable and cb slot to func. */
  CCallback cb;       /* Temporary callback state. */
  CTypeID1 hash[...]; /* Hash anchors for C type table. */
} CTState;

- size:
  - size   : size in bytes
  - nargs  : number of fixed arguments of a function
  - offset : offset in bytes from the start of the struct
  - value  : the actual constant value
  - attr   : value of the attribute
- sib :
  - field : function args or struc/union field.
  - const : constant value
  - sib?  :
    - ?? chain of attribute or object of the attribute
- name: GCRef to a string containing the identifier.
- next: chain for hash collisions in cts->hash (used for internalisation check)

- GEN
  cid : child id
  A   : allignement of 2^A bytes
- NUM
  B   : Boolean
  F   : Float
  c   : const
  v   : volatile
  U   : Unsigned
  L   : Long
- STRUCT
  u   : union
  V   : VLA
- PTR
  R   : reference
- ARRAY
  V^2 : Vector
  C   : Complex
- FUNC
  V^3 : Vararg
  S   : SSE arguments
  cc  : calling convention
- ATTRIB
  attrnum : Attributes number (type of the attribute,see CTA_* in lj_ctype.h)
- BITFIELD
  csz : size of the memory slot
  bsz : number of bits of the bit-field
  pos : starting position in bit inside the memory slot
- KW
  tok : token id


- typdef chain is unrolled during parsing (typdef is style internalized for futur
  reference but is not linked to the created type.)

lj_ctype.c:
-----------
- C type representation : convert CType to string.
  - lj_ctype_repr return a string representation of CType.
  - the main function is the ctype_repr that contains a switch on the ctype info
- C type information    :  getter for type info
- C type interning      : creation/internalization of ctype.
typedef struct CTRepr {
  char *pb, *pe;        /* Points to begining/end inside the buffer*/
  CTState *cts;
  lua_State *L;
  int needsp;           /* Next append needs an extra space character */
  int ok;               /* Indicate if buf is currently a valid type */
  char buf[CTREPR_MAX]; /* String buffer of the ctype being constructed */
} CTRepr;

lj_obj.h:
---------
- GCcdata struct

lj_cparse.h:
------------
typedef struct CPState {
  CPChar c;               /* Current character. */
  CPToken tok;            /* Current token. */
  CPValue val;            /* Token value. */
  GCstr *str;             /* Interned string of identifier/keyword. */
  CType *ct;              /* C type table entry. */
  const char *p;          /* Current position in input buffer. */
  SBuf sb;                /* String buffer for tokens. */
  lua_State *L;           /* Lua state. */
  CTState *cts;           /* C type state. */
  TValue *param;          /* C type parameters. */
  const char *srcname;    /* Current source name. */
  BCLine linenumber;      /* Input line counter. */
  int depth;              /* Recursive declaration depth. */
  uint32_t tmask;         /* Type mask for next identifier. */
  uint32_t mode;          /* C parser mode. */
  uint8_t packstack[...]; /* Stack for pack pragmas. */
  uint8_t curpack;        /* Current position in pack pragma stack. */
} CPState;

lj_cparse.c:
------------
- contain a simple lexer.
- a not valid c parser.

typedef struct CPDecl {
  CPDeclIdx top;     /* Top of declaration stack. */
  CPDeclIdx pos;     /* Insertion position in declaration chain. */
  CPDeclIdx specpos; /* Saved position for declaration specifier. */
  uint32_t mode;     /* Declarator mode. */
  CPState *cp;       /* C parser state. */
  GCstr *name;       /* Name of declared identifier (if direct). */
  GCstr *redir;      /* Redirected symbol name. */
  CTypeID nameid;    /* Existing typedef for declared identifier. */
  CTInfo attr;       /* Attributes. */
  CTInfo fattr;      /* Function attributes. */
  CTInfo specattr;   /* Saved attributes. */
  CTInfo specfattr;  /* Saved function attributes. */
  CTSize bits;       /* Field size in bits (if any). */
  CType stack[...];  /* Type declaration stack. */
} CPDecl;

lj_cdata.c:
-----------
- contains main function to handle cdata
  (allocations, free, finilizer, get, set and index)

lj_cconv.c:
-----------
- C type compatibility checks
- C type to C type conversion
- C type to TValue conversion
- TValue to C type conversion
- Initialize C type with TValues
  (Initialization of struct/union/array with TValues)
lj_carith.c:
------------
- implementation for all built-in cdata arithmetics.
  - pointers arithmetics
  - integer arithmetics
typedef struct CDArith {
  uint8_t *p[2]; /* data  of the two operands */
  CType  *ct[2]; /* ctype of the two operands */
} CDArith;

lj_ccall.c:
-----------
- handle ffi call handling such has parameters/return value per register.
- small array/struct decomposition by register passing.
- Register classes struct classification (regular, sse, memory)

lj_ccall.h:
-----------
typedef struct CCallState {
  void (*func)(void); /* Pointer to called function.      */
  uint32_t spadj;     /* Stack pointer adjustment.        */
  uint8_t nsp;        /* Number of stack slots.           */
  uint8_t retref;     /* Return value by reference.       */
  uint8_t ngpr;       /* Number of arguments in GPRs.     */
  uint8_t nfpr;       /* Number of arguments in FPRs.     */
  [...]
  FPRArg fpr[...];    /* Arguments/results in FPRs. (SSE) */
  GPRArg gpr[...];    /* Arguments/results in GPRs.       */
  GPRArg stack[...];  /* Stack slots.                     */
} CCallState;

lj_ccallback.c:
---------------
- cts->miscmap contains a maping between cb slot to the function pointers
- cts.cb.cbid is tbale mapping cb slot to CTypeID
- cts.cb.mcode is an mmap''ed executable page that contains a push of slot id and a
  jump to lj_vm_ffi_callback (the entry in this page correspond to the cb address provided to the c code)
- order of call
  - c call a callback address
    - arrive in the callback mcode page (push the appropriet slot id and call lj_vm_ffi_callback)
      - arrive in lj_vm_ffi_callback that charge in register the callback.fpr/gpr + stack pointers in registers
        - arrive in lj_ccallback_enter that prepare the lua state and do conversion of argument from c to lua type.
      - arrive in lj_vm_ffi_callback : execute the callback with this lua state
        - lua callback
      - arrive in |->cont_ffi_callback: call lj_ccallback_leave
        - arrive in lj_ccallback_leave convert return value from lua to c.
      - arrive in |->cont_ffi_callback: return to c code witht the return value in register/stack.
  - arrive in c code.

(in lj_ctype.h)
typedef struct CCallback {
  FPRCBArg fpr[...]; /* Arguments/results in FPRs. */
  intptr_t gpr[...]; /* Arguments/results in GPRs. */
  intptr_t *stack;   /* Pointer to arguments on stack. */
  void *mcode;       /* Machine code for callback func. pointers. */
  CTypeID1 *cbid;    /* Callback type table. */
  MSize sizeid;      /* Size of callback type table. */
  MSize topid;       /* Highest unused callback type table slot. */
  MSize slot;        /* Current callback slot. */
} CCallback;

lj_clib.c:
----------
- load/unload ffi library
- allow to index library using named symbol.
  - use platforme specific tool to explore the exposed c symbol.
  - every symbol is resolved only once and cached in the CLibrary cache table

lj_clib.h:
----------
/* C library namespace. */
typedef struct CLibrary {
  void *handle; /* Opaque handle for dynamic library loader. */
  GCtab *cache; /* Cache for resolved symbols. Anchored in ud->env. */
} CLibrary;

NEXT ??? WHEN ???
use for colision in the hash table ??
================================================================================
- valgrin on linux
- compile luajit whith uncommenting (CCDEBUG, DLUAJIT_USE_SYSMALLOC, DLUAJIT_USE_VALGRIND, DLUAJIT_ENABLE_GC64)
- use ./luajit/src/lj.supp file for the cmd bellow.
- cmd: "valgrind --tool=memcheck --leak-check=full --track-origins=yes --log-file='tests.txt' --suppressions=lj.supp ./mad all.mad -v"
================================================================================
- randre a gcobject never collectable by by gc.
- why allocator is global ?
- does gc goes through the lua stack.