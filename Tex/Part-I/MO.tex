%!TEX root = ../../FYP_Dissertation.tex

When looking at the timing of individual tests of the MAD test suite we can see
that most of the instability comes from the Model Object tests. In Figure
\ref{fig:failed-test}, we can see a screenshot of three failed timing tests that
were calibrated to run in roughly 0.5 seconds and that for this run needed respectively
6, 4 and 68 seconds. We need then to investigate the reason for such results.

\begin{figure}[H]
    \centering
	\includegraphics[width=0.8\textwidth]{./Images/failed-test.png}
    \caption{Timing screenshot}
    \label{fig:failed-test}
\end{figure}

The Lua programming language doesn't actually have an object model but provide
mechanisms that allow anyone to build a custom object model fitting his needs.
Next section will present the one that as been built for MAD.

%===============================================================================
% Model object description
%===============================================================================

\section{Model object description}
\label{Sec:MO-descriptinon}

MAD object module implements the necessary machinery to support prototype-based
programming. When reading an attribute on an object, either the value is present
in the child object and it is returned or the query is passed to the parent
object recursively until the value is found or the original \emph{Object} is
reached. When a value is written the value is simply stored in the current
object (no lookups are performed). To understand how this object model is
implemented, a grasp of how lua handles tables and metatables is required.

To keep it simple here, lua tables are key-value stores that return \emph{nil} by
default if a key is not defined (see Section \ref{Subsec:table} for more).
Users have the possibility to associate a metatable to any tables. A metatable
is actually a standard lua table that contains special metamethods of which
the keys are defined by the lua language. The one that we are interested here is
the \emph{\_\_index} metamethod that defines how a table should react when accessing
an undefined key. If this is a method, the requested key is passed to this method
and it is executed, but if this \emph{\_\_index} contains another table, then this
table is queried instead of the first one. This is this mechanism that has been
used in MAD to implement the model object. Figure \ref{fig:MO-descriptinon} below
shows a schematic of the implementation of MAD object model.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{./Images/MO.pdf}
    \caption{Implementation of MAD object model}
    \label{fig:MO-descriptinon}
\end{figure}

On this figure, \emph{Object2} is the child of \emph{Object1}. To represent an
object, three lua tables are actually needed. The first one (in dark blue) is
the actual object passed around and manipulated by the user. It doesn't actually
contain any user data so when queried, the index function of its metatable (in
green) is executed instead. This metatable is by default the same for all objects
unless it is explicitly modified by the user. This index function gets the
\emph{var} table (in light blue) of the object and try to index it with the
requested key. If the key is defined, the corresponding value is returned,
otherwise the chaining lookup is triggered. Let's look at the example in the
figure when trying to query an undefined key in \emph{Object2}.
First the index function query \emph{var2} that doesn't contain it. Then, since
\emph{Object2} is the metatable of \emph{var2} (see the \emph{[meta]} arrow) and
the \emph{\_\_index} of \emph{Object2} links to \emph{var1}, \emph{var1} is queried.
This chaining is done recursively to the \emph{var} tables of its parents until the
key is found or the hierarchy entirely unrolled.

%===============================================================================
% Performance analysis
%===============================================================================

\section{Performance analysis}
\label{Sec:MO-perf-analys}

First of all, we are going to see how the JIT can make this object model
efficient and hoist away  all those costly lookups. In fact, the object model
described in the previous section might seem very slow as accessing variables
provided by a distant parent necessitates a big chain of lookups. In practice it
is not necessarily the case. Let's look at an example. Figure \ref{fig:MO-ex}
shows a model hierarchy that is transcribed in MAD by the lua code below from
lines 3 to 9. Since LuaJIT mainly compile loops, we are going to look at the IR
code (see Section \ref{Subsec:IR}) generated by LuaJIT for the loop lines 12 to 14
using the dump module (see Section \ref{Sec:Dump-mode}).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{./Images/MO-ex.pdf}
    \caption{Object inheritance of the example}
    \label{fig:MO-ex}
\end{figure}

\begin{lstlisting}[style=LuaStyle]
local object in MAD

-- object hierarchy
local obj1  = object "obj1"  { l = 42 }
local obj2  = obj1   "obj2"  { }
local obj3  = obj2   "obj3"  { }
local obj41 = obj3   "obj41" { }
local obj42 = obj3   "obj42" { }

-- loop
local sum = 0
for i=1,1e7 do
	sum = sum + obj41.l + obj42.l
end
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[height=13cm]{./Images/trace-1a}
    \includegraphics[height=13cm]{./Images/trace-1b}
    \caption{Screenshot of the example's loop trace}
    \label{fig:MO-ex-dump}
\end{figure}

Figure \ref{fig:MO-ex-dump} shows a screenshot of the dump trace. Without looking
at it too much in detail, we can see in the red squares labeled number one, the
access to the \emph{\_\_index} function that access the \emph{\_\_var} table to
query the "l" variable. Since this variable is not present in the first object
the hierarchy is unrolled three time (see the 3 "l" literals and the three
"\emph{\_\_index}" literals) in the red squares labeled with the number 2.
We have twice the same unrolling because the left screenshot shows the
unrolling for the first object (\emph{obj41}) and the right one shows the second
object (\emph{obj42}).

Now let's extract some general understanding from this example. Fist, the actual loop
is only the part in red labeled with the number three. We can see that it only
consists of the loop's counter and the additions. All other operations
from the model object has been successfully moved out of the loop making the loop
itself very small and efficient. This is the power of luaJIT. It can do that
using the loop optimization that consists of unrolling the loop once before the
actual loop itself executing all invariant operation and guards only once
(see \ref{Subsec:opt-loop} on loop optimization). Another thing to note here is
that the hierarchy chaining and the \emph{\_\_index} function is completely
inlined in the trace. This is always the case, there is never any explicit
control-flow possible in a trace with the exception of the actual LOOP currently
recorded, meaning that all functions and control-flow are inlined and specialized
to the runtime values.\\

Now let's look at another example based on the same hierarchy but slightly more
complex. Here the last level objects (\emph{obj4[n]}) are dynamic. Figure
\ref{fig:MO-ex-dump2} shows a screenshot of the dump trace for the second
example and we can clearly see that the hierarchy chaining is present both before
the loop (on the left) and inside the loop (on the right). This means that the
compiler hasn't been able to detect the invariance and produce a code similar to
the previous example, but it still manages to produce a single trace handling the
entire loop making it still performing better than with the VM interpreter.

\begin{lstlisting}[style=LuaStyle]
local object in MAD

-- object hierarchy
local obj1 = object "obj1" { l = 42 }
local obj2 = obj1   "obj2" { }
local obj3 = obj2   "obj3" { }

-- list of obj4[n]
local list = table.new(1e7, 0)
for i=1,1e7 do
	lists[i] = obj3 "obj4" {}
end

-- loop
local sum = 0
for i=1,1e7 do
	sum = sum + lists[i].l
end
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[height=13cm]{./Images/trace-2a}
    \includegraphics[height=13cm]{./Images/trace-2b}
    \caption{Screenshot of the second example's loop trace}
    \label{fig:MO-ex-dump2}
\end{figure}

%===============================================================================
% Instability possible explanation
%===============================================================================

\section{Instability possible explanation}
\label{Sec:MO-insta}

% - performance issue
%	- possible explanation
%   - explane how the JIT can fail the model object
% loop optimization is a problem here when the list is heterogenous in numbers of stages
%  permanant blacklisting
% removing blacklisting after a flush
% allow blacklisted function and or
%   - but not triggers a compilation

%===============================================================================
% Performance of Sequence iterator
%===============================================================================

\section{Performance of \emph{Sequence} iterator}
\label{Sec:MO-perf-iter}

% forward vs backward iterator
% difference in performance
% comming from the nedd of the l
	% different depth to get l
	% show a visual dump
% new object model ?

%===============================================================================
% Model object alternative design
%===============================================================================

\section{Model object alternative design}
\label{Sec:MO-alt-design}

% exploration of other type of object model
%  performance compareson / explanation
% didn't help on average